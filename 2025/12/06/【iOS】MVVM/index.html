<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>【iOS】MVVM | A5pkRd</title><meta name="author" content="Northern Lights"><meta name="copyright" content="Northern Lights"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="MVC模式MVC的前世：  这个架构中，三个实体联系太过紧密，每个实体都知道另外的两个实体。这就导致了复用性能急剧下降。 apple MVC : 苹果官方推荐使用的MVC，结构大致如下：https:&#x2F;&#x2F;developer.apple.com&#x2F;library&#x2F;archive&#x2F;documentation&#x2F;General&#x2F;Conceptual&#x2F;DevPedia-CocoaCore&#x2F;MVC.html  友">
<meta property="og:type" content="article">
<meta property="og:title" content="【iOS】MVVM">
<meta property="og:url" content="http://tommywutong.cn/2025/12/06/%E3%80%90iOS%E3%80%91MVVM/">
<meta property="og:site_name" content="A5pkRd">
<meta property="og:description" content="MVC模式MVC的前世：  这个架构中，三个实体联系太过紧密，每个实体都知道另外的两个实体。这就导致了复用性能急剧下降。 apple MVC : 苹果官方推荐使用的MVC，结构大致如下：https:&#x2F;&#x2F;developer.apple.com&#x2F;library&#x2F;archive&#x2F;documentation&#x2F;General&#x2F;Conceptual&#x2F;DevPedia-CocoaCore&#x2F;MVC.html  友">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/Biscoffee/piccbes/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20251109152046_365_51.jpg">
<meta property="article:published_time" content="2025-12-06T06:39:20.000Z">
<meta property="article:modified_time" content="2025-12-09T08:06:35.115Z">
<meta property="article:author" content="Northern Lights">
<meta property="article:tag" content="iOS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Biscoffee/piccbes/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20251109152046_365_51.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "【iOS】MVVM",
  "url": "http://tommywutong.cn/2025/12/06/%E3%80%90iOS%E3%80%91MVVM/",
  "image": "https://raw.githubusercontent.com/Biscoffee/piccbes/master/微信图片_20251109152046_365_51.jpg",
  "datePublished": "2025-12-06T06:39:20.000Z",
  "dateModified": "2025-12-09T08:06:35.115Z",
  "author": [
    {
      "@type": "Person",
      "name": "Northern Lights",
      "url": "https://blog.csdn.net/2402_86720949?spm=1000.2115.3001.5343"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://tommywutong.cn/2025/12/06/%E3%80%90iOS%E3%80%91MVVM/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【iOS】MVVM',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"></head><body><div id="web_bg" style="background-image: url(/img/background.png);"></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/apple4.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/avatar-icon.png" alt="Logo"><span class="site-name">A5pkRd</span></a><a class="nav-page-title" href="/"><span class="site-name">【iOS】MVVM</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">【iOS】MVVM<a class="post-edit-link" href="https://github.com/Biscoffee/Biscoffee.github.io/edit/main/source/_posts/_posts/【iOS】MVVM.md" title="Edit" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-12-06T06:39:20.000Z" title="Created 2025-12-06 14:39:20">2025-12-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-12-09T08:06:35.115Z" title="Updated 2025-12-09 16:06:35">2025-12-09</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h1><p><strong>MVC的前世：</strong></p>
<p><img src="https://raw.githubusercontent.com/Biscoffee/piccbes/master/162c33f6cb4982b3%7Etplv-t2oaga2asx-jj-mark%3A3024%3A0%3A0%3A0%3Aq75.awebp" alt="Traditional MVC"></p>
<p>这个架构中，三个实体联系太过紧密，每个实体都知道另外的两个实体。这就导致了复用性能急剧下降。</p>
<p><strong>apple MVC</strong> :</p>
<p>苹果官方推荐使用的MVC，结构大致如下：<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html">https://developer.apple.com/library/archive/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html</a></p>
<p><img src="https://raw.githubusercontent.com/Biscoffee/piccbes/master/model_view_controller_2x.png" alt="Model-View-Controller design pattern"></p>
<p>友链：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9e8fd85b61e0">https://www.jianshu.com/p/9e8fd85b61e0</a></p>
<p>可以看出<code>View</code>跟<code>Model</code>事实上是没有交互的，由<code>Controller</code>负责<code>Model</code>与<code>View</code>之间的交互，交互越多，<code>Controller</code>就越臃肿，更别提实际运用中有些还去掉了<code>View</code>层或者<code>Model</code>层。目前对MVC架构划分是<code>Model</code>作为<code>数据管理者</code>，<code>View</code>作为<code>数据展示者</code>，<code>Controller</code>作为<code>数据加工者</code>。</p>
<p>然而在iOS中<code>Controller</code>中由于有苹果内定的一些视图的生命周期在里面，比如<code>viewDidLoad</code>等等，于是就出现了一些关于iOS的MVC架构方面的争论，有些认为在iOS开发中并没有什么<code>View</code>和<code>Controller</code>，只有<code>Model+ViewController</code>。</p>
<p>这里，给出一个某大咖关于MVC框架的理解：</p>
<blockquote>
<p>Model应该做的：</p>
<ol>
<li>给ViewController提供数据</li>
<li>给ViewController储存数据提供接口</li>
<li>提供经过抽象的业务逐渐，供Controller调度</li>
</ol>
<p>Controller应该做：</p>
<ol>
<li>管理生命周期</li>
<li>生成所有的View的实例，并放入ViewController</li>
<li>监听来自View与业务有关的时间，通过和Model合作，来完成对应事件的业务。</li>
</ol>
<p>View应该做：</p>
<ol>
<li>响应与业务无关的时间，并因此引发动画效果，点击反馈（如果合适还是放在View去做）</li>
<li>界面元素表达</li>
</ol>
</blockquote>
<p>但是，几十年过去了，我们对于 MVC 这种设计模式真的用得好吗？其实不是的，MVC 这种分层方式虽然清楚，但是如果使用不当，很可能让大量代码都集中在 Controller 之中，让 MVC 模式变成了 <code>Massive View Controller</code> 模式。（巨屎控制器）</p>
<p><strong>MVC现实情况</strong></p>
<p><img src="https://raw.githubusercontent.com/Biscoffee/piccbes/master/162c34103bb9e544%7Etplv-t2oaga2asx-jj-mark%3A3024%3A0%3A0%3A0%3Aq75.awebp" alt="Realistic Cocoa MVC"></p>
<p><code>Cocoa MVC</code>鼓励你使用大型的视图控制器（<strong>Massive</strong> View Controllers），由于他们都参与到了视图（<code>View</code>）的生命周期中了以至于很难说他们是分离的。尽管你仍有能力分流一些业务逻辑和数据转换功能到模型（<code>Model</code>）中，但是当涉及到把工作分流到视图（<code>View</code>）中去时你就诶有更多的选择了，因为在大多数时候视图（<code>View</code>）的所有职责是把动作传递到控制器（<code>Controller</code>）中。视图控制器（<code>View Controller</code>）最终最为所有控件的委托和数据源，通常负责调度和取消网络请求…应有尽有</p>
<p>因此，<strong>M——VC</strong> 可能是对iOS开发中<code>iOS</code>模式更为准确的解读，也更为准确地描述了我们日常开发编写的MVC代码。</p>
<p>就像在日常开发中的制定也cell，正是直接由View来调Model，所以事实上典型的MVC以及违背了，但是人们一直不觉得这有哪些不对。如果严格遵守<code>MVC</code>的话，你会把对<code>cell</code>的设置放在<code>Controller</code>中，不向<code>View</code>传递一个<code>Model</code>对象，这样就会大大增加<code>Controller的体积</code>。</p>
<p>综上所述，<code>Cocoa MVC</code>是一个相当糟糕的事情。但是如果你没有打算在项目架构上耗费太多时间，那么他就是你的最好选择。。</p>
<blockquote>
<p>Cocoa MVC is the best architectural pattern in term of the speed of the development. 在开发速度上面<code>Cocoa MVC</code>是最好的架构模式。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Biscoffee/piccbes/master/162c3426165a927e%7Etplv-t2oaga2asx-jj-mark%3A3024%3A0%3A0%3A0%3Aq75.awebp" alt="img"></p>
<h2 id="如何解决Controller臃肿的问题？"><a href="#如何解决Controller臃肿的问题？" class="headerlink" title="如何解决Controller臃肿的问题？"></a>如何解决Controller臃肿的问题？</h2><p>这里我摘录一段博客：</p>
<blockquote>
<p>对于 View 来说，你如果抽象得好，那么一个 App 的动画效果可以很方便地移植到别的 App 上，而 Github 上也有很多 UI 控件，这些控件都是在 View 层做了很好的封装设计，使得它能够方便地开源给大家复用。</p>
<p>对于 Model 来说，它其实是用来存储业务的数据的，如果做得好，它也可以方便地复用。</p>
<p>说完 View 和 Model 了，那我们想想 Controller，Controller 有多少可以复用的？我们写完了一个 Controller 之后，可以很方便地复用它吗？结论是：非常难复用。在某些场景下，我们可能可以用 <code>addSubViewController</code> 之类的方式复用 Controller，但它的复用场景还是非常非常少的。</p>
<p>如果我们能够意识到 Controller 里面的代码不便于复用，我们就能知道什么代码应该写在 Controller 里面了，那就是那些不能复用的代码。在我看来，Controller 里面就只应该存放这些不能复用的代码，这些代码包括：</p>
<ul>
<li>在初始化时，构造相应的 View 和 Model。</li>
<li>监听 Model 层的事件，将 Model 层的数据传递到 View 层。</li>
<li>监听 View 层的事件，并且将 View 层的事件转发到 Model 层。</li>
</ul>
<p>如果 Controller 只有以上的这些代码，那么它的逻辑将非常简单，而且也会非常短。</p>
</blockquote>
<h3 id="把每一个网络请求封装为单例类"><a href="#把每一个网络请求封装为单例类" class="headerlink" title="把每一个网络请求封装为单例类"></a>把每一个网络请求封装为单例类</h3><p>这其实是设计模式中的Command模式，优点如下：</p>
<ul>
<li><strong>解耦网络库：</strong>C/M不直接依赖AFN</li>
<li><strong>公共逻辑统一处理：</strong>鉴权、token、版本号、统一错误处理、统一header等都可以在基类处理</li>
<li><strong>缓存/数据持久化：</strong>可以自行实现（如离线队列等）</li>
<li><strong>更好的拓展性能：</strong>支持插件、日志、JSON校验、请求组合（并行/串联）、短点续传等</li>
</ul>
<p>这部分代码从Controller剥离后，不但简化了Controller逻辑，也达到了网络层的代码复用</p>
<blockquote>
<p>Controller / ViewModel<br>      ↓ 使用 Request 对象（构造 + 配置）<br>Request (BaseRequest)<br>      ↓ 调用 RequestManager（封装 AFNetworking）<br>RequestManager -&gt; AFHTTPSessionManager<br>      ↓ 插件/拦截器（可选）<br>Response / Error / Cache</p>
</blockquote>
<h3 id="把界面拼装到专门类中"><a href="#把界面拼装到专门类中" class="headerlink" title="把界面拼装到专门类中"></a>把界面拼装到专门类中</h3><p>新手喜欢在controller中把UILabel UIButton UITextfield 往<code>self.view</code>上用<code>addsubView</code>方法放。可以两种方法把代码从Controller剥离。</p>
<ol>
<li>构建专门的UIView子类，来负责这些控件的拼装。不过稍微麻烦的，你需要把这些控件的事件回调先接管，再一一暴露回controller</li>
<li>用一个静态Util类，帮你做UIView的拼接工作。</li>
</ol>
<p>方法一比较适合大型的项目，需要统一样式与行为。而方案二适合于少量封装和小工程量代码</p>
<h3 id="构造ViewModel"><a href="#构造ViewModel" class="headerlink" title="构造ViewModel"></a>构造ViewModel</h3><p>MVC不是不能用ViewModel？ MVVM的优点一样可以借鉴。具体来说就是吧ViewController给View传递数据这个过程，抽象为构建ViewModel的过程。</p>
<p>ViewMode包含：</p>
<ol>
<li>从service获取ViewModel</li>
<li>把ViewModel交给View</li>
</ol>
<p>同时在具体的实践中，我们可以创建构造专门的ViewModel工厂类。</p>
<h3 id="专门构建储存类"><a href="#专门构建储存类" class="headerlink" title="专门构建储存类"></a>专门构建储存类</h3><p>storage专门做：</p>
<ul>
<li>本地缓存</li>
<li>数据迁移</li>
</ul>
<p><strong>All in all：</strong></p>
<p>通过这些操作，Controller中最终只有两类代码： 生命周期和事件响应。</p>
<p><strong>Controller 本身不写：网络、数据处理、UI 布局、业务逻辑、存储逻辑、字符串拼接、格式化。</strong></p>
<h1 id="MVVM模式"><a href="#MVVM模式" class="headerlink" title="MVVM模式"></a>MVVM模式</h1><p><strong>MVVM</strong>，则是由MVC演化来的：</p>
<p><img src="https://raw.githubusercontent.com/Biscoffee/piccbes/master/d3b53a5bfd8e1ee0a385792f1d44b4cc-20251206175525265.png" alt="在这里插入图片描述"></p>
<p>抽出<code>ViewMode</code>层负责数据与视图的交互部分，它主要作用是拿到原始的数据，根据具体业务逻辑需要进行处理，之后将处理好的东西塞到View中去，其职责之一是静态模型，表示View显示自身所需的数据，这使View具有更清晰定义的任务，即呈现视图模型提供的数据，总结为一句话就是<strong>与View直接对应的Model，逻辑上是属于Model层</strong>。</p>
<p><code>Controller</code>仅协调各部分的绑定关系以及逻辑处理，唯一关注的是使用来自ViewModel的数据配置和管理各种View，不需要了解web调用，model对象等，这些都交给ViewModel操作。</p>
<p><img src="https://raw.githubusercontent.com/Biscoffee/piccbes/master/16a93467d920551e%7Etplv-t2oaga2asx-jj-mark%3A3024%3A0%3A0%3A0%3Aq75.png" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/Biscoffee/piccbes/master/16a98841446de26f%7Etplv-t2oaga2asx-jj-mark%3A3024%3A0%3A0%3A0%3Aq75.png" alt="img"></p>
<p>ViewModel并不一定只服务一个View，同理，一个Controller也可以持有很多ViewModel，来实现不同的逻辑控制多重的View。</p>
<p>Controller唯一关注的是使用来自ViewModel的数据配置和管理各种View，并让ViewModel知道何时发生需要更改上游数据的相关用户输入。 Controller不需要知道网络请求、数据库操作以及Model等，这样就让Controller更集中的去处理具体的业务逻辑。</p>
<p><img src="https://raw.githubusercontent.com/Biscoffee/piccbes/master/16ab051be8baa492%7Etplv-t2oaga2asx-jj-mark%3A3024%3A0%3A0%3A0%3Aq75.png" alt="img"></p>
<p>在<code>MVVM</code>中，View和ViewCotroller正式联系在一起，我们把他视为一个组件，他们都不能直接引用Model，而是应用视图模型ViewModel，虽然会轻微增加代码量，但是总体上减少了代码的复杂度。</p>
<p>MVVM 的注意事项</p>
<ul>
<li><code>view</code> 引用<code>viewModel</code> ，但反过来不行（即不要在<code>viewModel</code>中引入<code>#import UIKit.h</code>，任何视图本身的引用都不应该放在<code>viewModel</code>中）（PS：<strong>基本要求，必须满足</strong>）</li>
<li><code>viewModel</code> 引用<code>model</code>，但反过来不行</li>
<li>ViewController尽量不涉及业务逻辑，让<code>ViewModel</code>去做这些事情</li>
</ul>
<p>大致实现以下效果：</p>
<p><img src="https://raw.githubusercontent.com/Biscoffee/piccbes/master/16ab0b7d9fedbc4f%7Etplv-t2oaga2asx-jj-mark%3A3024%3A0%3A0%3A0%3Aq75.png" alt="图片一"></p>
<p><img src="https://raw.githubusercontent.com/Biscoffee/piccbes/master/16ab0b87cca96d3d%7Etplv-t2oaga2asx-jj-mark%3A3024%3A0%3A0%3A0%3Aq75.png" alt="图片二"></p>
<p> <strong>MVC</strong></p>
<blockquote>
<p><strong><em>优点：</em></strong> 通用架构； 处理耦合度高的逻辑方便； <strong><em>缺点：</em></strong> 耦合度高； 复用性差； 测试性差；</p>
</blockquote>
<p><strong>MVVM</strong></p>
<blockquote>
<p><strong><em>优点：</em></strong> 耦合度低； 复用性高； 测试性高； 层次更清晰； 重构成本低； <strong><em>缺点：</em></strong> 处理耦合度高的逻辑比较复杂； 若加入RAC，增加学习成本； 一些Bug比较难调试</p>
</blockquote>
<p>MVVM 在使用当中，通常还会利用双向绑定技术，使得 Model 变化时，ViewModel 会自动更新，而 ViewModel 变化时，View 也会自动变化。所以，MVVM 模式有些时候又被称作：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Model_View_ViewModel">model-view-binder</a> 模式。</p>
<p>具体在 iOS 中，可以使用 KVO 或 Notification 技术达到这种效果。</p>
<h2 id="MVVM的问题"><a href="#MVVM的问题" class="headerlink" title="MVVM的问题"></a>MVVM的问题</h2><p>在实际使用中，确实能够使得Model层和View层解耦，但是如果实现MVVM中的双向绑定的话，就需要引入更多复杂的框架实现了。</p>
<p>某种意义来说，就是数据绑定使MVVM变得复杂难用了。由于Obj - C 没有像Swift那样的原生数据绑定支持，我们需要手动实现数据绑定机制。</p>
<ul>
<li>KVO View可以监听ViewModel中属性的变化，并自动更新。但是比较难用容易出问题，最好还是用RAC封装</li>
<li>通知中心（NSNotifiction）提供了一种松耦合的通信方式，ViewModel可以通过通知来告知View状态的变化。适用于有全局事件</li>
<li>代理模式（Delegate）ViewModel可以定义协议，让View遵循协议并实现相应的方法来响应状态变化。</li>
<li>block 最简单最小巧（黎果菲方案，组长评价 “很可以”）</li>
<li>RAC第三方库</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Biscoffee/piccbes/master/def67c783cbe43db9ead83b5d2d516e2%7Etplv-k3u1fbpfcp-jj-mark%3A3024%3A0%3A0%3A0%3Aq75.awebp" alt="在这里插入图片描述"></p>
<h3 id="block"><a href="#block" class="headerlink" title="block"></a>block</h3><p>block 的作用：保存一段代码，到恰当的时候调用,很多时候block是代理的一种优化方案</p>
<ol>
<li>block比protocol更灵活，更高聚合，低耦合。 例如AFN的网络框架中，就可以将“准备请求参数”的代码和“处理后台返回数据”的代码放在一起。</li>
<li>block的灵活还体现在他可以当作方法参数以及返回值。 Block可以作为函数参数或者函数的返回值，而其本身又可以带输入参数或返回值。</li>
</ol>
<h3 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h3><p>实现的方式中KVO不需要通知中心将可以实现属性的监听；与block以及代理相比，可以减少大量的代理方法以及block中的处理逻辑代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)addObserver:(NSObject *)anObserver</span><br><span class="line">         forKeyPath:(NSString *)keyPath</span><br><span class="line">            options:(NSKeyValueObservingOptions)options</span><br><span class="line">            context:(void *)context</span><br></pre></td></tr></table></figure>
<p>anObserver：观察者对象，这个对象必须实现<code>observeValueForKeyPath:ofObject:change:context:</code>方法，以响应属性的修改通知,否则将报错<code>An -observeValueForKeyPath:ofObject:change:context: message was received but not handled.</code></p>
<p>keyPath：被监听的属性。这个值不能为nil。</p>
<p>options：监听选项，这个值可以是NSKeyValueObservingOptions选项的组合。关于监听选项，我们会在下面介绍。</p>
<p>context：任意的额外数据，我们可以将这些数据作为上下文数据，它会传递给观察者对象的observeValueForKeyPath:ofObject:change:context:方法。这个参数的意义在于用于区分同一对象监听同一属性的多个不同的监听。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)dealloc &#123;</span><br><span class="line">    // 移除监听</span><br><span class="line">    [self.webVIew removeObserver:self forKeyPath:@&quot;xxxx&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/2402_86720949/article/details/154543600?fromshare=blogdetail&amp;sharetype=blogdetail&amp;sharerId=154543600&amp;sharerefer=PC&amp;sharesource=2402_86720949&amp;sharefrom=from_link">KVO</a></p>
<h3 id="ReactiveCocoa"><a href="#ReactiveCocoa" class="headerlink" title="ReactiveCocoa"></a>ReactiveCocoa</h3><p>一句话总结：<strong>RAC 就是用“信号”（Signal）来代替“事件”，让事件处理变得更简洁、自动、链式、干净。</strong></p>
<p>他可以监听UI事件、文本变化、属性变化（不需要写KVO），代替代理/回调。</p>
<p>RAC是函数响应式编程（FRP）框架。ReactiveCocoa结合了几种编程风格：函数式编程（Functional Programming）响应式编程（Reactive Programming）</p>
<p>优雅集中体现在函数式编程,安全体现在响应式编程。</p>
<blockquote>
<p>使用RAC解决问题，就不需要考虑调用顺序。每一次操作都写成一系列嵌套的方法中，使代码高聚合，方便管理。</p>
</blockquote>
<p>函数式编程（Functional Programming）和响应式编程（React Programming）也是当前很火的两个概念，它们的结合可以很方便地实现数据的绑定。于是，在 iOS 编程中，ReactiveCocoa 横空出世了，它的概念都非常 新，包括：</p>
<ul>
<li>函数式编程（Functional Programming），函数也变成一等公民了，可以拥有和对象同样的功能，例如当成参数传递，当作返回值等。看看 Swift 语言带来的众多函数式编程的特性，就你知道这多 Cool 了。</li>
<li>响应式编程（React Programming），原来我们基于事件（Event）的处理方式都弱了，现在是基于输入（在 ReactiveCocoa 里叫 Signal）的处理方式。输入还可以通过函数式编程进行各种 Combine 或 Filter，尽显各种灵活的处理。</li>
<li>无状态（Stateless），状态是函数的魔鬼，无状态使得函数能更好地测试。</li>
<li>不可修改（Immutable），数据都是不可修改的，使得软件逻辑简单，也可以更好地测试。</li>
</ul>
<p>关于这个第三方库的具体内容笔者现在还没有具体了解，具体的使用以及源码的相关内容会在后续更新。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://blog.csdn.net/2402_86720949?spm=1000.2115.3001.5343">Northern Lights</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://tommywutong.cn/2025/12/06/%E3%80%90iOS%E3%80%91MVVM/">http://tommywutong.cn/2025/12/06/%E3%80%90iOS%E3%80%91MVVM/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/iOS/">iOS</a></div><div class="post-share"><div class="social-share" data-image="https://raw.githubusercontent.com/Biscoffee/piccbes/master/微信图片_20251109152046_365_51.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>请我喝杯咖啡吧～</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/weichatpay.png" target="_blank"><img class="post-qr-code-img" src="/img/weichatpay.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/12/05/SDWebImage/" title="SDWebImage"><img class="cover" src="/img/iOS.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">SDWebImage</div></div><div class="info-2"><div class="info-item-1"> 笔者最近在完成抖音关注页面的仿写过程中了解到可以使用SDWebImage来进行头像加载的优化，当时只来得及了解其简单使用。现在有时间了，准备了解一下他的内部源码实现。  一、简介SDWebImage是iOS中提供图片加载的第三方库，可以给UIKit框架中的控件比如UIImageView和UIButton提供从网络上下载和缓存的图片。它的接口十分简洁，如果给UIImageView控件添加图片...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Northern Lights</div><div class="author-info-description">一句话介绍不了我</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Biscoffee"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#MVC%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">MVC模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3Controller%E8%87%83%E8%82%BF%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">如何解决Controller臃肿的问题？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%8A%E6%AF%8F%E4%B8%80%E4%B8%AA%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%B0%81%E8%A3%85%E4%B8%BA%E5%8D%95%E4%BE%8B%E7%B1%BB"><span class="toc-number">1.1.1.</span> <span class="toc-text">把每一个网络请求封装为单例类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%8A%E7%95%8C%E9%9D%A2%E6%8B%BC%E8%A3%85%E5%88%B0%E4%B8%93%E9%97%A8%E7%B1%BB%E4%B8%AD"><span class="toc-number">1.1.2.</span> <span class="toc-text">把界面拼装到专门类中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0ViewModel"><span class="toc-number">1.1.3.</span> <span class="toc-text">构造ViewModel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%93%E9%97%A8%E6%9E%84%E5%BB%BA%E5%82%A8%E5%AD%98%E7%B1%BB"><span class="toc-number">1.1.4.</span> <span class="toc-text">专门构建储存类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MVVM%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">MVVM模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MVVM%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.</span> <span class="toc-text">MVVM的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#block"><span class="toc-number">2.1.1.</span> <span class="toc-text">block</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KVO"><span class="toc-number">2.1.2.</span> <span class="toc-text">KVO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReactiveCocoa"><span class="toc-number">2.1.3.</span> <span class="toc-text">ReactiveCocoa</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/12/06/%E3%80%90iOS%E3%80%91MVVM/" title="【iOS】MVVM"><img src="https://raw.githubusercontent.com/Biscoffee/piccbes/master/微信图片_20251109152046_365_51.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【iOS】MVVM"/></a><div class="content"><a class="title" href="/2025/12/06/%E3%80%90iOS%E3%80%91MVVM/" title="【iOS】MVVM">【iOS】MVVM</a><time datetime="2025-12-06T06:39:20.000Z" title="Created 2025-12-06 14:39:20">2025-12-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/05/SDWebImage/" title="SDWebImage"><img src="/img/iOS.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SDWebImage"/></a><div class="content"><a class="title" href="/2025/12/05/SDWebImage/" title="SDWebImage">SDWebImage</a><time datetime="2025-12-05T06:01:15.000Z" title="Created 2025-12-05 14:01:15">2025-12-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/04/About-us/" title="About us"><img src="/img/iOS.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="About us"/></a><div class="content"><a class="title" href="/2025/12/04/About-us/" title="About us">About us</a><time datetime="2025-12-04T13:09:15.000Z" title="Created 2025-12-04 21:09:15">2025-12-04</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Northern Lights</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">繁</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="/js/tw_cn.js?v=5.5.2"></script><div class="js-pjax"></div><script async data-pjax src="/"></script></div></body></html>